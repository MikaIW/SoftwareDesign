# -*- coding: utf-8 -*-
"""
Created on Tue Feb 11 11:34:57 2014

@author: pruvolo
"""

from random import randint
from math import *
import Image

def build_random_function(min_depth, max_depth):
    """
    creates a random function with its inputs as other random functions, with depth defined between min_depth and max_depth (min_depth < max_depth)
    for each loop through, build_random_function inputs the new function into the previous function, until max_depth is 1 and the new function is finally x or y.
    """

    xylist = ["x","y"]
    
    if max_depth <= 1:
        return xylist[randint(0,1)]
        
    a = build_random_function(min_depth-1,max_depth-1)
    b = build_random_function(min_depth-1,max_depth-1)  
    
    args = [a,b]    
    args2 = [a]
    args3 = [b]
    
    prod = ["prod",args[0],args[1]]
    cos_pi = ["cospi",args2[0]]
    sin_pi = ["sinpi",args2[0]]
    x = args2[0]
    y = args3[0]
    avg = ["avg",args[0],args[1]]
    cube = ["^3",args2[0]]
     
    funclist = [prod,cos_pi,sin_pi,avg,cube,x,y]                                  
    
    if min_depth >1:
        return funclist[randint(0,4)]
    elif min_depth <= 1:
        return funclist[randint(0,6)]
        
    

def evaluate_random_function(f, x, y):
    """
    takes the function list generated by build_random_function and converts it into a mathematical function
    """    

    if f[0] == "prod":
        return evaluate_random_function(f[1],x,y)*evaluate_random_function(f[2],x,y)
    elif f[0] == "cospi":
        return cos(pi*evaluate_random_function(f[1],x,y))
    elif f[0] == "sinpi":
        return sin(pi*evaluate_random_function(f[1],x,y))
    elif f[0] == "avg":
        return (evaluate_random_function(f[1],x,y))+(evaluate_random_function(f[2],x,y))/2
    elif f[0] == "^3":
        return evaluate_random_function(f[1],x,y)**3
    elif f[0] == "x":
        return x
    elif f[0] == "y":
        return y



def remap_interval(val, instart, inend, outstart, outend):
    """ Maps the input value that is in the interval [input_interval_start, input_interval_end]
        to the output interval [output_interval_start, output_interval_end].  The mapping
        is an affine one (i.e. output = input*c + b).
    
        TODO: please fill out the rest of this docstring
    """
     
    val2 = ((val-instart)/(inend-instart))*(outend-outstart) + outstart
    return val2    
    
    
def makeart():
    """
    Creates an image with the depths you assign to functions r, g, and b
    """
    
    im = Image.new("RGB",(1600,900))
    pic = im.load()
   
    r = build_random_function(4,16)
    g = build_random_function(3,17)
    b = build_random_function(5,18)
    
    for i in range (1600):
        for j in range (900):
            i2 = remap_interval(i,1.0,1600.0,-1.0,1.0)
            j2 = remap_interval(j,1.0,900.0,-1.0,1.0)    
            rvalue = evaluate_random_function(r,i2,j2)
            bvalue = evaluate_random_function(b,i2,j2)
            gvalue = evaluate_random_function(g,i2,j2)
            r1 = remap_interval(rvalue,-1.0,1.0,0.0,255.0)
            b1 = remap_interval(bvalue,-1.0,1.0,0.0,255.0)
            g1 = remap_interval(gvalue,-1.0,1.0,0.0,255.0)
            R = int(r1)
            B = int(b1)
            G = int(g1)
            pic[i,j] = (R,G,B)
            #if j == 100:
                #print rvalue,bvalue,gvalue,r1,b1,g1    
    im.save("image28.bmp")

makeart()